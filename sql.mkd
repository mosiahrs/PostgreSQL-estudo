# PostgreSQL

É um SGBD-OR (sistema gerenciador de banco de dados Objeto Relacional), é openSource.

- Linguagem procedural 
Em varias linguagens como JAVA.

- Pouca manutenção.

Ele é comparável ao BD ORACLE ou SQL SERVER da Mycrosoft.

Documentação:
https://www.postgresql.org/docs/

# 

<div align="center">

##	`SQL - Strutcture Query Language`
</div>

- **DML** - Linguagem de manipulação de dados:
  *INSERT*, *UPDATE* e *DELETE*
- **DDL** - Linguagem de Definição de Dados
   *CREATE* e *DROP*
 - **DCL** - Linguagem de controle de Dados
   *GRANT* - autoriza ao usuário executar comandos
   *REVOKE* - remove ou restringe a capacidade de um usuário executar comandos.
 - **DTL** - Liguagem de transação de dados
    *BEGIN WORK* (ou *BEGIN TRANSACTION*) - COMMIT - ROLLBACK
  - **DQL** - Linguagem de Consulta de Dados
     *SELECT* - é o principal comando SQL.
     
     
<div align="center">

![image](https://user-images.githubusercontent.com/100864562/218334672-fe74b6c4-5c6a-4c40-b49b-df01c69652f8.png)

</div>


**Case-sensitive**  - Na distinção dos caracteres dos dados da tupla, já em relação à sintaxe não é...

##  Usando SELECT - 04 a 06

    
	--  Selecionando colunas pelo nome:
	
    SELECT nome_coluna1,nome_coluna2 FROM nome_tabela;

	-- Selecionando todas as colunas:
	
    SELECT * FROM TABELA1;
    
    -- Selecionando de maneira mais específica:
    
    SELECT nome_coluna FROM tabela 
    WHERE condicional OR outra_condicional


**IS NOT NULL** - pode ser usado para fazer verificações para valores não nulos (ou nulos).

**()** - Usar os parenteses para dividir os blocos de condição durante a busca, tabela verdade e etc...

**nome_coluna AS apelido** - usando o *AS* podemos criar um apelido para a coluna durante a busca, e será apresentado o resultado com esse valor no "titulo" da coluna.

> Esse valor, não é registrado na memória durante o filtro WHERE, para que seja possível deve-se adicionar essa consulta dentro de um bloco e fazer o filtro a partir desse bloco.

Problema:

    SELECT salario AS ganhos, comissao AS bonus 
    FROM func WHERE ganhos < 5000;
    
    ERROR: 1054 : Unknown column 'ganhos' in 'where clause'

Solução: 

    SELECT * FROM
    (SELECT salario AS ganhos, comissao AS bonus
    FROM func) X WHERE ganhos < 5000;
    
<div align="center">
<img width="500px" src="https://user-images.githubusercontent.com/100864562/218344280-3b4eaa2e-43bb-4ef6-9eff-09af463f0266.png" /></div>

#### Concatenação - CONCAT

    SELECT CONCAT(nome, ' STRING ', cargo) AS msg
    FROM fun WHERE deptnum = 10;

	Saida:		        +---------------------------+
				| msg	                    |
				+---------------------------+
				| Fulano String Gerente     |
				| Beltrano String CEO       |
				| Ciclano String CTO        |
				+---------------------------+

> No Postgres pode ser utilizado double pipe || para fazer a concatenção;

##  `Estruturas Condicionais - CASE WHEN`

Estrutura de seleção IF ELSE, ex


    CASE
        WHEN _`boolean-expression`_ THEN
          _`statements`_
      [ WHEN _`boolean-expression`_ THEN
          _`statements`_
        ... ]
      [ ELSE
          _`statements`_ ]
    END CASE;

Exemplo:

    SELECT nome,salario 
	    CASE 
		    WHEN salario <= 2000 THEN 'baixo'
		    WHEN salario >= 4000 then 'alto'
			ELSE 'medio'
		END as resultado 
	FROM func;
	
			+-------+----------+-------------+
			| nome  | salario  |  resultado  |
			+-------+----------+-------------+
			| Jose  |    1500  |  	baixo	 |
			| Joao  |    5000  |	alto     |
			| Maria |    3000  |	medio    | 
			+-------+----------+-------------+

## `COALESCE`
A `COALESCE`função retorna o primeiro de seus argumentos que não é nulo. Nulo é retornado apenas se todos os argumentos forem nulos. Geralmente é usado para substituir um valor padrão por valores nulos quando os dados são recuperados para exibição.

		SELECT coalesce(comissao, 0) FROM func;
> A Coluna comissão será exibida, com todos os valores NULL substituídos por zero, que foi o argumento passado após a virgula.

 ## **`Union x Union All`**
Duas formas de unir consultas, devendo trazer a mesma quantidade de colunas.

**Funcionalidade:** o union elimina os valores duplicados enquanto o union all não altera o result set.

**Performance:** Em questão de performance o union all consome menos recurso computacional, mesmo o union trazendo menos dados. O processo de remoção de valores duplicados torna o union menos performático, sendo nesse caso necessário avaliar a situação específica para utilizar cada um deles.
#
**Not in:** Utilizado para verificar o que contem em uma tabela que não contem na outra.  

**Distinct:** Tudo o que é único nas colunas referidas no SELECT.


Combinando os dois:

		SELECT DISTINCT DPTNUM FROM AREA 
		WHERE DEPTNUM not in (SELECT DPTNUM FROM FUN);

> Dessa forma a consulta retorna os valores únicos e que não se repetem em nas tabelas.

#### Operadores:

<img width="500px" src="https://user-images.githubusercontent.com/100864562/218342889-f45d1169-4715-4ea2-9e24-c111c4b8dbe4.png" />



